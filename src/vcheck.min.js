"use strict";
if (!window.tnuc) {
	var tnuc = {};
}

tnuc.tmpl = function (template, opts) {
	var div = document.createElement('div'),
		frag = document.createDocumentFragment(),
		children = div.childNodes;
	
	
	if (!opts instanceof Array) {
		opts = [opts];
	}
	
	if (typeof this.tmpl[template] === "function") {
		div.innerHTML = this.tmpl[template].apply(this.tmpl, opts);
		
		while (children.length) {
			frag.appendChild(div.firstChild);
		}
	}
	
	return frag;
};
tnuc.tmpl.serverList = function (servers) {
	return servers.map(function (server) {
		var chunks = server.split(':');
		return [
			'<a href="http://www.ventrilo.com/status.php?hostname=',
				encodeURIComponent(chunks[0]),
				'&amp;port=',
				encodeURIComponent(chunks[1]),
				'" class="tnuc_server">',
				server,
				'<span class="tnuc_rmserver">X</a>',
			'</a>'
		].join('');
	}).join('');
};
tnuc.tmpl.overlay = function (conf, currentServer) {
	return [
		'<div id="tnuc_overlay" class="tnuc">',
			'<button class="big tnuc_toggle">toggle ventcheck</button>',
			'<button class="big tnuc_phantoms">toggle phantoms</button>',
			'<button class="big tnuc_startmin">minimized view</button>',
			'<button class="big tnuc_autorefresh">auto-refresh</button>',
			'<button class="big tnuc_refresh">refresh</button>',
			'<div id="tnuc_serverlist">',
				'<b>Server List:</b>',
				'<div id="tnuc_servers"></div>',
				'<input id="tnuc_server" placeholder="ip.or.host.com:1234" value="', currentServer, '"/>',
				'<button class="tnuc_addserver">add</button>',
			'</div>',
			'<button class="big tnuc_website">visit tnuc.org</button>',
		'</div>'
	].join('');
};
tnuc.tmpl.fullView = function (serverData, clientCollection, conf) {
		// Channels ordered by numClients DESC
	var channels = clientCollection.
			getChannels().
			sort(tnuc.fn.innerSort('numClients')).
			reverse(),
		// Clients ordered by online time ASC
		clients = clientCollection.
			getClients().
			sort(tnuc.fn.innerSort('ontime'));
	
	
	// Move Lobby to the end of the server array
	// So it's shown at the bottom
	channels = channels.filter(tnuc.filter.isNormalChannel).
		concat(channels.filter(tnuc.filter.isLobbyChannel));
		
	
	// Remove Phantoms if showPhantoms is false;
	channels = channels.filter(tnuc.filter.containsRealClients);
	clients  = clients.filter(tnuc.filter.isRealClient);
		
		
	return ['<h2>', serverData.hostAndPort, '</h2>',
		'<table border="0" width="500" cellpadding="4" cellspacing="1" class="bld" align="center">',
			'<tr class="hdr">',
			'<td class="r" width="250">Online Users</td>',
			'<td class="l" width="250"><strong>',
				(clientCollection.numClients - clientCollection.numPhantoms),
				(conf.showPhantoms && clientCollection.numPhantoms ?
					" (+ " + clientCollection.numPhantoms + " Phantoms)" :
					""),
				'</strong> / ', serverData["Max Clients"], '</td>',
			'</tr>',
			'<tr class="sum">',
			'<td class="r">Admins</td>',
			'<td class="l">', clientCollection.numAdmins, '</td>',
			'</tr>',
			'<tr class="sum">',
			'<td class="r" width="250">Server Uptime</td>',
			'<td class="l" width="250">', serverData.Uptime, '</td>',
			'</tr>',
			'<tr class="sum">',
			'<td class="r" width="250">Unhidden Info</td>',
			'<td class="l" width="250">', (serverData.unhiddenText || "<i>nothing</i>"), '</td>',
			'</tr>',
		'</table>',

		'<div id="tnuc_tables">',
			'<div id="tnuc_chans">',
				'<span>Channel Overview</span><br/>',
				'<table width="220px" cellpadding="4" cellspacing="1" class="ctr">',
					'<tr class="hdr">',
						'<td>Flags</td>',
						'<td>Users</td>',
						'<td>Recent</td>',
					'</tr>',
					
					channels.
						map(function (currentChannel) {
							var currentCid = currentChannel.cid;
							
							return '<tr class="bld' /*+ (currentCid === 0 ? " sum" : "")*/ + '"' + ' data-cid="' + currentCid + '">' +
								'<td>' + (currentCid === 0 ? "L" : "") + currentChannel.getFlags() + '</td>' +
								'<td>' + currentChannel.numClients + '</td>' +
								'<td>' +
									(currentCid === (clients[0] || "").cid ? '<span class="br">&#149;&#149;</span>' : "") +
									(currentCid === (clients[1] || "").cid ? '<span class="by">&#149;&#149;</span>' : "") +
									(currentCid === (clients[2] || "").cid ? '<span class="bg">&#149;&#149;</span>' : "") +
									(currentCid === (clients[3] || "").cid ? '<span class="bb">&#149;&#149;</span>' : "") +
								'</td>' +
								'</tr>';
						}).
						join(''),
					
				'</table>',
			'</div>',

			'<div id="tnuc_conns">\nRecent Connections\n<br />',
				'<table width="220px" border="0" cellpadding="4" cellspacing="1" class="ctr">',
					'<tr class="hdr">',
					'<td>Flags</td>',
					'<td>Ontime</td>',
					'<td>Name</td>',
					'</tr>',
					
					clients.
						slice(0, (channels.length > 10 && channels.length) || 10).
						map(function (client, i) {
							var colorClass = ["fr", "fy", "fg", "fb"][i] || "";
							
							return '<tr class="bld ' + colorClass + '" data-cid="' + client.cid + '">' + 
								'<td>' + client.flags + '</td>' + 
								'<td>' + tnuc.fn.formatTime(client.ontime) + '</td>' + 
								'<td>' + client.fixedName + '</td>' + 
								'</tr>';
						}).
						join(''),
					
				'</table>',
			'</div>',
			'<br style="clear:both" />',
		'</div>'
	].join('');
};



tnuc.tmpl.minView = function (serverData, clientCollection, conf) {
		// Channels ordered by numClients DESC, remove Phantoms
	var channels = clientCollection.
			getChannels().
			sort(tnuc.fn.innerSort('numClients')).
			reverse().
			filter(tnuc.filter.containsRealClients),
		// Clients ordered by online time ASC, remove Phantoms
		clients = clientCollection.
			getClients().
			sort(tnuc.fn.innerSort('ontime')).
			filter(tnuc.filter.isRealClient),
		lobby = channels.filter(tnuc.filter.isLobbyChannel)[0] || null,
		now = new Date(),
		unhiddenShort = serverData.unhiddenText.replace("Comm", "Xomm").replace(/[^A-Z]/g, '');
	
	// Detach lobby
	channels = channels.filter(tnuc.filter.isNormalChannel);
	
	return [
		'<b title="click the X in the bottom right hand corner to switch back to normal view">',
		(clientCollection.numClients - clientCollection.numPhantoms),
		" @ ",
		
		channels.
			map(function (channel) {
				return (
					channel.cid === clients[0].cid ? '<span class="fr">' + channel.numRealClients + '</span>' : (
					channel.cid === clients[1].cid ? '<span class="fy">' + channel.numRealClients + '</span>' : (
					channel.cid === clients[2].cid ? '<span class="fg">' + channel.numRealClients + '</span>' : (
					channel.cid === clients[3].cid ? '<span class="fb">' + channel.numRealClients + '</span>' : 
					channel.numRealClients
				))));
		}).join('-'),
		
		(lobby ? (
			lobby.cid === clients[0].cid ? '<span class="fr">+' + lobby.numRealClients + '</span>' : (
			lobby.cid === clients[1].cid ? '<span class="fy">+' + lobby.numRealClients + '</span>' : (
			lobby.cid === clients[2].cid ? '<span class="fg">+' + lobby.numRealClients + '</span>' : (
			lobby.cid === clients[3].cid ? '<span class="fb">+' + lobby.numRealClients + '</span>' :
			"+" . lobby.numRealClients)))) :
			""
		),
		
		"<br />",
		clients.
			slice(0,4).
			map(function (client, i) {
				return '<span class="' + ["fr", "fy", "fg", "fb"][i] + '">' + tnuc.fn.formatTime(client.ontime) +  '</span>';
		}).join(' ; '),
		
		'<br />',
		tnuc.fn.zeropad(now.getHours()), ':',
		tnuc.fn.zeropad(now.getMinutes()), ':',
		tnuc.fn.zeropad(now.getSeconds()),
		' - ', clientCollection.numAdmins, 'A ',
		(unhiddenShort ? '[' + unhiddenShort + ']' : ''),
		'</b>',
		'<button class="tnuc_endmin">X</div>'
	].join('');
};



tnuc.fn = {};
/**
 * Left-pads single digits numbers with a zero.
 * 12 => 12
 *  1 => 01
 *
 * @param {int} num The Number
 * @param {String} Zero-padded number
 */
tnuc.fn.zeropad = function (num) {
	return (num > 9 && num) || "0" + num;
};



/**
 * Take an array of objects and returns and extract
 * the properties with a given name. Return them as an array.
 * Optionally takes a fallback value used when the property
 * is not found in one of the objects.
 *
 * extract([{a:1},{a:2},{a:3}], "a") 
 *    => [1,2,3]
 * 
 * @param {Array} arr Array to extract values from
 * @param {String} prop Property to extract
 * @param {mixed} fallback Fallback value if property not found
 */
tnuc.fn.extract = function (arr, prop, fallback) {
	var ret = [],
		i, 
		len;
	
	for (i = 0, len = arr.length; i < len; i += 1) {
		ret.push(arr[i][prop] || fallback);
	}
	return ret;
};



/**
 * Take a property name and return a sorting function
 * that sorts a given array of objects by the property
 * with the given name.
 * 
 * [{b:5},{b:3},{b:7}].sort(innerSort("b"))
 *    => [{b:3},{b:5},{b:7}]
 *
 * @param {String} prop Property name
 * @return {Function} Sorting function
 */
tnuc.fn.innerSort = function (prop) {
	return function (a, b) {
		if (a[prop] === b[prop]) {
			return 0;
		}
		return a[prop] < b[prop] ? -1 : 1;
	};
};



tnuc.fn.boolFilter = function (property, bool) {
	bool = !bool;
	
	return function (element) {
		var notProp =  !element[property]; // fuck you jslint
		return bool === notProp;
	};
};



/**
 * Remove all text nodes from a given DOM element
 * 
 * @param {DOMElement} node Node to remove text nodes from
 */
tnuc.fn.trimTextNodes = function (node) {
	var children = node.childNodes,
		i,
		len;
		
	for (i = 0, len = children.length; i < len; i += 1) {
		if (children[i].nodeType === 3) {
			node.removeChild(children[i]);
			i -= 1;
			len -= 1;
		}
	}
};



/**
 * Properly format a timespan given in seconds
 * 4     =>       "4"
 * 61    =>    "1:01"
 * 6701  => "1:18:21"
 * 89234 =>    ">24h"
 *
 * @param {int} s Timespan in seconds  
 * @return {String} Formatted string
 */
tnuc.fn.formatTime = function (s) {
	if (s >= 86400) {
		return ">24h";
	}
	if (s < 60) {
		return "" + s;
	}
	if (s < 3600) {
		return parseInt(s / 60, 10) + 
			":" + 
			tnuc.fn.zeropad(s % 60);
	}
	return parseInt(s / 3600, 10) + 
		":" + 
		tnuc.fn.zeropad(parseInt((s % 3600) / 60, 10)) + 
		":" + 
		tnuc.fn.zeropad(s % 60);
};



/**
 * Encode HTML Special Chars
 * & => &amp;   < => &gt;    > => &lt;
 *
 * @param {mixed} text Text String to encode
 * @return {string} Text with encoded special chars
 */
tnuc.fn.htmlEntities = (function () {
	var elem = document.createElement('p');
	
	return function (text) {
		elem.innerText = "" + text;
		return elem.innerHTML;
	};
}());



/**
 * Merge two objects (write all props of B to A, overwrite).
 * Augments object A, does NOT create a new object.
 */
tnuc.fn.merge = function (a, b) {
	var hasProp = Object.prototype.hasOwnProperty,
		prop;
		
	for (prop in b) {
		if (hasProp.call(b, prop)) {
			a[prop] = b[prop];
		}
	}
	
	return a;
};



/**
 * Returns an array of all of an object's own properties that contain truthy values
 *
 * @param {Object} obj Input object
 * @return {Array} Array containing the names of all truthy properties.
 */
tnuc.fn.getTruthyProps = function (obj) {
	var hasProp = Object.prototype.hasOwnProperty,
		prop,
		ret = [];
		
	for (prop in obj) {
		if (hasProp.call(obj, prop)) {
			if (obj[prop]) {
				ret.push("" + prop);
			}
		}
	}
	
	return ret;
};


tnuc.events = {};
(function (doc) {
	var docElem = doc.documentElement,
		matchesSelector = docElem.matchesSelector || 
			docElem.webkitMatchesSelector || 
			docElem.mozMatchesSelector || 
			docElem.oMatchesSelector || 
			docElem.msMatchesSelector,
		
		// Maps of arrays of delegated events ({'sel': selector, 'cb': callback}) for each event
		events = {},
		// Map of internal event listeners for each event
		eventcbs = {};
		
	
	tnuc.events.delegate = function (selector, event, callback) {
		if (!events[event]) {
			events[event] = [];
			eventcbs[event] = function (e) {
				var handlers = events[event],
					i, len,
					doReturnFalse = false;
				
				for (i = 0, len = handlers.length; i < len; i += 1) {
					if (matchesSelector.call(e.target, handlers[i].sel)) {
						if (handlers[i].cb.call(e.target, e)) {
							doReturnFalse = true;
						}
					}
				}
				
				if (doReturnFalse) {
					return false;
				}
			};
			document.addEventListener(event, eventcbs[event], false);
		}
		events[event].push({'sel': selector, 'cb': callback});
	};
	
	tnuc.events.undelegate = function (selector, event, callback) {
		var i, len, handlers = events[event];
		
		// check all events of given type and remove if selector and callback match
		for (i = 0, len = handlers.length; i < len; i += 1) {
			if (handlers[i].sel === selector && handlers[i].cb === callback) {
				handlers.splice(i, 1);
				i -= 1;
				len -= 1;
			}
		}
		
		// if the last listener for an event is removed, remove the global internal listener
		if (!handlers.length) {
			document.removeEventListener(event, eventcbs[event], false);
			delete events[event];
			delete eventcbs[event];
		}
	};	
}(document));


/**
 * localStorage handlers to read and write data.
 */
tnuc.persist = {};
(function (window) {
	var supported = false;
	
	try {
		window.localStorage.setItem("tnuc_vcheck_fdetect", "" + (+new Date()));
		supported = true;
	} catch (e) {}
	
	tnuc.persist.get = function (key, fallback) {
		var data;
		
		if (!supported) {
			return fallback;
		}
		
		data = window.localStorage.getItem(key);
		return (data && JSON.parse(data)) || fallback;
	};
	
	
	tnuc.persist.set = function (key, val) {
		if (!supported) {
			return;
		}
		
		window.localStorage.setItem(key, JSON.stringify(val));
	};
}(window));




tnuc.cls = {};
tnuc.cls.Client = function (flags, cid, ontime, uid, comment) {
	this.uid = uid.replace(/[\r\n]/g, '');
	this.cid = parseInt(cid, 10);
	this.ontime = parseInt(ontime, 10);
	this.flags = flags.replace(/[\r\n]/g, '');
	this.comment = comment;

	this.isInLobby = (this.cid === 0);
	this.isRealClient = (this.flags !== "P");
	this.isAdmin = (this.flags === "A");
	
	this.fixedName = (
		!this.isRealClient ? '-phntm-' : (
			this.uid === "XXXXXXXX" ? '-hidden-' : this.uid
		)
	);
};


tnuc.cls.Channel = function (cid) {
	this.cid = cid;
	this.clients = [];
	this.numClients = 0;
	this.numRealClients = 0;
};

tnuc.cls.Channel.prototype.addClient = function (client) {
	this.clients.push(client);
	this.numClients += 1;
	
	if (client.isRealClient) {
		this.numRealClients += 1;
	}
};
tnuc.cls.Channel.prototype.getFlags = function () {
	return (this.cid === 0 ? 'L' : '') + tnuc.fn.extract(this.clients, 'flags').sort().join('');
};


tnuc.cls.ClientCollection = function () {
	this.channels = {};
	this.clients = [];
	
	this.numClients = 0;
	this.numAdmins = 0;
	this.numPhantoms = 0;
	this.namesUnhidden = false;
	this.commentsUnhidden = false;
};

tnuc.cls.ClientCollection.prototype.addClient = function (client) {
	if (!client instanceof tnuc.cls.Client) {
		throw "Arg must be an instance of cls.Client";
	}
	
	if (!this.channels[client.cid]) {
		this.channels[client.cid] = new tnuc.cls.Channel(client.cid);
	}
	
	this.channels[client.cid].addClient(client);
	this.clients.push(client);
	
	this.numClients += 1;
	
	// Check for admins/phantoms (mutually exclusive)
	if (client.isAdmin) {
		this.numAdmins += 1;
	} else if(!client.isRealClient) {
		this.numPhantoms += 1;
	}
	
	// Check for unhidden name/comment data
	if (client.comment) {
		this.commentsUnhidden = true;
	}
	if (client.uid !== 'XXXXXXXX') {
		this.namesUnhidden = true;
	}
};
tnuc.cls.ClientCollection.prototype.getClients = function () {
	return this.clients;
};
tnuc.cls.ClientCollection.prototype.getChannels = function () {
	var hasProp = Object.prototype.hasOwnProperty,
		prop,
		ret = [];
		
	for (prop in this.channels) {
		if (hasProp.call(this.channels, prop)) {
			ret.push(this.channels[prop]);
		}
	}
	
	return ret;
};
tnuc.cls.ClientCollection.prototype.getUnhidden = function () {
	var ret = [];
	
	if (this.commentsUnhidden) {
		ret.push("Comments");
	}
	if (this.namesUnhidden) {
		ret.push("Names");
	}
	
	return ret;
};


(function (window, document, tnuc) {
	var clientData,
		serverData,
		serverList,
		
		// Ventcheck container element
		target,
		
		// localStorage keys used to persist data
		storageKeys = {
			config: "tnuc_vcheck_config",
			servers: "tnuc_vcheck_servers"
		},
		
		conf = {
			showPhantoms: false,
			minView: false,
			autoShow: true,
			autoRefresh: 0
		},
		
		// Timeout used by the autoRefresh feature
		autoRefreshTimeout,
		
		rowMouseOut = function (tableName, className) {
			return function (e) {
				var rows = [].slice.call(document.getElementById(tableName).getElementsByClassName(className), 0),
					i, len;
					
				for (i = 0, len = rows.length; i < len; i += 1) {
					rows[i].classList.remove(className);
				}
				this.parentNode.classList.remove(className);
				
				e.stopPropagation();
			};
		},
		rowMouseIn = function (tableName, className) {
			return function (e) {
				var cid = this.parentNode.getAttribute('data-cid'),
					rows = [].slice.call(document.getElementById(tableName).getElementsByTagName('tr'), 1),
					i, len;
				
				for (i = 0, len = rows.length; i < len; i += 1) {
					if (rows[i].getAttribute('data-cid') === cid) {
						rows[i].classList.add(className);
					}
				}
				this.parentNode.classList.add(className);
				
				e.stopPropagation();
			};
		},
		
		
		/**
		 * Returns the current server
		 */
		getCurrentServer = function () {
			var host = document.querySelector('input[name="hostname"]').value.trim() || "",
				port = document.querySelector('input[name="port"]').value.trim() || "";
			
			return (host && port && host + ":" + port) || "";
		},
		
		
		/**
		 * Extracts server specific information from the 
		 * already loaded ventrilo page.
		 */
		parseServerData = function () {
			var data = {},
				digitsReg = /^\d+$/;
			
			// so naive
			if (!document.getElementsByTagName("center")[1]) {
				throw "No valid Ventrilo status data found";
			}
			
			[].slice.call(
				document.
					getElementsByTagName("center")[1].
					getElementsByTagName("tr")
			).forEach(function (tr) {
				var key = tr.cells[0].innerText.trim(),
					val = tr.cells[1].innerText.trim();
				
				// Parse int values where it makes sense
				if (digitsReg.test(val)) {
					val = parseInt(val, 10);
				}

				data[key] = val;
			});
			
			// Format uptime (remove seconds and parens)
			data.Uptime = data.Uptime.
				replace(/^[^\(]+\(/, '').
				replace(/\)[^\)]*$/, '').
				replace(/^1 days/, '1 day');
			
			// Check if channels are unhidden (Channel Count is an empty string if not)
			data.Unhidden = (+data["Channel Count"]) > 0 ? ["Channels"] : [];
			return data;
		},
		
		
		/**
		 * Extracts information about the online clients 
		 * from the already loaded ventrilo status page.
		 */
		parseClientData = function () {
			var clientCollection = new tnuc.cls.ClientCollection();
			
			[].slice.call(
				document.
					getElementsByTagName("center")[2].
					getElementsByTagName("tr"),
				1
			).forEach(function (tr) {
				var cells = tr.cells,
					tmpClient = new tnuc.cls.Client(
						cells[0].innerText,
						cells[2].innerText,
						cells[3].innerText,
						cells[5].innerText,
						cells[6].innerText
					);
				
					clientCollection.addClient(tmpClient);
			});
			
			return clientCollection;
		},
		
		
		render = function (serverData, clientData, conf) {
			var bodyclasses = document.body.classList;
			
			target.innerHTML = "";
			
			if (conf.minView) {
				bodyclasses.add("tnucmin");
				target.appendChild(tnuc.tmpl('minView', [serverData, clientData, conf]));
			} else {
				bodyclasses.remove("tnucmin");
				target.appendChild(tnuc.tmpl('fullView', [serverData, clientData, conf]));
			}
		},
		
		toggleVentcheck = function (e) {
			document.body.classList.toggle("tnuc");
			
			conf.autoShow = !conf.autoShow;
			tnuc.persist.set(storageKeys.config, conf);
			
			e.preventDefault();
		},
		
		toggleMin = function (e) {
			conf.minView = !conf.minView;
			tnuc.persist.set(storageKeys.config, conf);
			
			if (conf.minView) {
				// autoShow if switching to min
				document.body.classList.add("tnuc");
			}
			render(serverData, clientData, conf);

			e.preventDefault();
		},
		
		
		

		togglePhantoms = function (e) {
			conf.showPhantoms = !conf.showPhantoms;
			tnuc.persist.set(storageKeys.config, conf);
			
			render(serverData, clientData, conf);
			
			e.preventDefault();
		},

		updateServerList = function() {
			var listElem = document.getElementById('tnuc_servers');
			
			listElem.innerHTML = "";
			listElem.appendChild(tnuc.tmpl('serverList', [serverList]));
		},
		
		addServer = function (e) {
			var tfield = document.getElementById('tnuc_server'),
				val = (tfield.value || "").replace(/\s/g, '').toLowerCase();
						
			if (!/^[\w]((-|\.)?[\w]+?)+?:\d+$/.test(val)) {
				if (val) {
					alert("invalid hostname/port");
				}
				return;
			}
			
			serverList = tnuc.persist.get(storageKeys.servers, []);
			
			if (serverList.indexOf(val) === -1) {
				tfield.value = "";
				tfield.focus();
				
				serverList.push(val);
				serverList.sort();
				
				tnuc.persist.set(storageKeys.servers, serverList);
			}
			
			updateServerList();
		},
		
		removeServer = function (e) {
			var val = this.parentNode.innerText.slice(0, 0 - this.innerText.length),
				index;
			
			serverList = tnuc.persist.get(storageKeys.servers, []);
			
			index = serverList.indexOf(val);
			if (serverList.indexOf(val) > -1) {
				serverList.splice(index, 1);
				
				tnuc.persist.set(storageKeys.servers, serverList);
			}
			
			updateServerList();
			
			e.stopPropagation();
			e.preventDefault();
		},
		
		init = function () {
			var serv;
			
			// Run only once, and only on the ventrilo.com status page
			if (tnuc.mutex || !(/^https?:\/\/(.+\.)?ventrilo.com\/status\.php/.test(location.href))) {
				return;
			}
			tnuc.mutex = true;
			
			// get current server info (hostname / port)
			serv = getCurrentServer();
			
			// Force www to ensure access to localStorage
			if (location.hostname !== "www.ventrilo.com") {
				alert('Redirecting to WWW.ventrilo.com. If your bookmarks point to ventrilo.com (without the "www") please update them accordingly. See http://ventcheck.tnuc.org for more information.');
				location.href = 
					"http://www.ventrilo.com/status.php" + 
					(serv ? 
						"?hostname=" + encodeURIComponent(serv.replace(":", "_")).replace("_", "&port=") : 
						""
					);
				return true;
			}
			
			// Set up filters
			tnuc.filter = {};
			tnuc.filter.isLobbyChannel = tnuc.fn.boolFilter('cid', 0);
			tnuc.filter.isNormalChannel = tnuc.fn.boolFilter('cid', 1);
			tnuc.filter.isRealClient = tnuc.fn.boolFilter('isRealClient', 1);
			tnuc.filter.containsRealClients = tnuc.fn.boolFilter('numRealClients', 1);
						
			// Merge default config with data from localStorage
			conf = tnuc.fn.merge(conf, tnuc.persist.get(storageKeys.config, {}));
			serverList = tnuc.persist.get(storageKeys.servers, []);
			
			// remove plain text nodes from the body
			// because fuck them, that's why
			tnuc.fn.trimTextNodes(document.body);
				
			// Initialise target element
			target = document.createElement("div");
			target.id = "tnuc_wrap";
			document.body.appendChild(target);
			
			// Insert stylesheet
			// Uncomment these if used as a bookmarklet.
			// s = document.createElement('link');
			// s.rel = "stylesheet";
			// s.type = "text/css";
			// s.href = "http://flocalhost/vcjs/style.css?" + (+new Date());
			// (document.head || document.documentElement).appendChild(s);
			
			// Display overlay
			document.body.appendChild(tnuc.tmpl('overlay', [conf, (serverList.indexOf(serv) > -1 ? "" : serv)]));
			updateServerList();
			document.title = (serv ? serv + " - " : "") + "Ventcheck";
			
			try {
				// Parse Data
				serverData = parseServerData();
				clientData = parseClientData();
				serverData.hostAndPort = serv;
				
				// Stringify unhidden data for later output
				serverData.unhiddenText = serverData.Unhidden.concat(clientData.getUnhidden()).sort().join(', ');
				
				// Event delegation (only on success)
				tnuc.events.delegate('.tnuc_toggle', 'click', toggleVentcheck);
				tnuc.events.delegate('.tnuc_phantoms', 'click', togglePhantoms);
				tnuc.events.delegate('#tnuc_conns tr:not(.hdr) td', 'mouseover', rowMouseIn('tnuc_chans', 'hovered'));
				tnuc.events.delegate('#tnuc_conns tr:not(.hdr) td', 'mouseout', rowMouseOut('tnuc_chans', 'hovered'));
				tnuc.events.delegate('#tnuc_chans tr:not(.hdr) td', 'mouseover', rowMouseIn('tnuc_conns', 'hovered'));
				tnuc.events.delegate('#tnuc_chans tr:not(.hdr) td', 'mouseout', rowMouseOut('tnuc_conns', 'hovered'));
				tnuc.events.delegate('.tnuc_endmin, .tnuc_startmin', 'click', toggleMin);
				
				render(serverData, clientData, conf);
				
				if (conf.autoShow) {
					document.body.classList.add("tnuc");
				}
				if (parseInt(conf.autoRefresh, 10)) {
					autoRefreshTimeout = setTimeout(function () { location.reload(); }, parseInt(conf.autoRefresh, 10));
				}
			} catch (e) {
				[].slice.call(
						document.querySelectorAll('.tnuc_toggle,.tnuc_phantoms')
					).forEach(function (e) {
						e.innerText = "SERVER NOT FOUND";
						e.classList.add("error");
					});
			}
			
			// Event delegation (always)
			tnuc.events.delegate('.tnuc_addserver', 'click', addServer);
			tnuc.events.delegate('.tnuc_rmserver', 'click', removeServer);
			tnuc.events.delegate('.tnuc_website', 'click', function () { location.href = "http://tnuc.org"; });
			tnuc.events.delegate('.tnuc_refresh', 'click', function () { location.reload(); });
			
		};
	
	init();
}(window, document, tnuc));